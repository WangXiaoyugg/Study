<!doctype html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport"          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>HTML5 Crop Image</title>    <style>        body {text-align: center;}        #label {border:1px solid #ccc;background: #fff;text-align: center;height: 300px;        width: 300px;margin: 20px auto;position: relative;}        #get_image {position: absolute;}        #edit_pic {position: absolute;display: none;background: #000;}        #cover_box {position: absolute;z-index: 9999;display: none;top:0px;left: 0px;}        #show_edit{margin:0 auto;display: inline-block;}        #show_pic {height: 100px;width: 100px;border:2px solid #000;overflow: hidden;        margin: 0 auto;display: inline-block;}        input,button{outline: none;border:none;border-radius: 10px;background: deepskyblue;color:#fff;}    </style></head><body><input type="file" id="post_file" name="file" accept="image/*"><button id="save_button">Save</button><div id="label">    <canvas id="get_image"></canvas>    <p>        <canvas id="cover_box"></canvas>        <canvas id="edit_pic"></canvas>    </p></div><p>    <span id="show_edit"></span>    <span id="show_pic"><img src="" alt=""></span></p><script>//t.px t.py分别表示在实时预览区域的背景图片的坐标//t.sx，t.sy， t.sHeight， t.sWidth分别表示图片的横纵坐标和宽高//用img直接插入页面，就无法自适应居中了，如果使用canvas绘制图片，// 不但能使图片自适应居中以及能等比例缩放，并且方便把图片的坐标，// 尺寸大小传给后来的遮罩层(id为label的div)，// 这样能根据图片的坐标以及图片的尺寸大小来绘制遮罩层。    var postFile = {        init:function () {            var t = this;            t.regional = document.getElementById('label');            t.getImage = document.getElementById('get_image');            t.editPic = document.getElementById('edit_pic');            t.editBox = document.getElementById('cover_box');            t.px = 0;            t.py = 0;            t.sx = 15;            t.sy = 15;            t.sheight = 150;            t.swidth = 150;            t.isSave = false;            document.getElementById('post_file').addEventListener('change',t.handleFiles,false);            document.getElementById('save_button').onclick = function () {                if(!t.isSave) return alert('请上传图片');                t.editPic.height = t.sheight;                t.editPic.width = t.swidth;                var ctx = t.editPic.getContext('2d');                var img = new Image();                img.src = t.imgUrl;                img.onload = function () {                    ctx.drawImage(img,t.sx,t.sy,t.sheight,t.swidth,0,0,t.sheight,t.swidth);                    document.getElementById('show_pic').getElementsByTagName('img')[0].src = t.editPic.toDataURL();                }            }        },        handleFiles:function () {            var fileList = this.files[0];            var oFReader = new FileReader();            oFReader.readAsDataURL(fileList);            oFReader.onload = function (oFREvent) {                postFile.paintImage(oFREvent.target.result);            }        },        paintImage:function (url) {            var t = this;            var createCanvas = t.getImage.getContext('2d');            var img = new Image();            img.src = url;            img.onload = function(){                if(img.width < t.regional.offsetWidth && img.height < t.regional.offsetHeight){                    t.imgWidth = img.width;                    t.imgHeight = img.height;                }else {                    var pWidth = img.width/(img.height / t.regional.offsetHeight);                    var pHeight = img.height /(img.width /t.regional.offsetWidth);                    t.imgWidth = img.width > img.height ? t.regional.offsetWidth:pWidth;                    t.imgHeight = img.height > img.width ? t.regional.offsetHeight:pHeight;                }                t.px = (t.regional.offsetWidth - t.imgHeight) / 2 + 'px';                t.py = (t.regional.offsetHeight - t.imgHeight) / 2 + 'px';                t.getImage.height = t.imgHeight;                t.getImage.width = t.imgWidth;                t.getImage.style.left = t.px;                t.getImage.style.top = t.py;                createCanvas.drawImage(img,0,0,t.imgWidth,t.imgHeight);                t.imgUrl = t.getImage.toDataURL();;                t.cutImage();                t.drag();                t.isSave = true;            }        },        cutImage:function () {            var t = this;            t.editBox.height = t.imgHeight;            t.editBox.width = t.imgWidth;            t.editBox.style.display = 'block';            t.editBox.style.left = t.px;            t.editBox.style.top = t.py;            var cover = t.editBox.getContext('2d');            cover.fillStyle = 'rgba(0,0,0,0.5)';            cover.fillRect(0,0,t.imgWidth,t.imgHeight);            cover.clearRect(t.sx,t.sy,t.sheight,t.swidth);            document.getElementById('show_edit').style.background = 'url('+t.imgUrl +')' + -t.sx +'px ' + -t.sy +'px no-repeat';            document.getElementById('show_edit').style.height = t.sheight + 'px';            document.getElementById('show_edit').style.width = t.swidth + 'px';        },        drag:function () {            var t = this;            var draging = false;            var startX = 0;            var startY = 0;            document.getElementById('cover_box').onmousemove = function (e) {                var pageX = e.pageX - (t.regional.offsetLeft+this.offsetLeft);                var pageY  = e.pageY - (t.regional.offsetTop + this.offsetTop);                if(pageX > t.sx && pageX < t.sx + t.swidth && pageY > t.sy && pageY < t.sy + t.sheight){                    this.style.cursor = 'move';                    this.onmousedown = function (e){                        draging = true;                        t.ex = t.sx;                        t.ey = t.sy;                        startX = e.pageX - (t.regional.offsetLeft+this.offsetLeft);                        startY  = e.pageY - (t.regional.offsetTop + this.offsetTop);                    };                    window.onmouseup = function () {                        draging = false;                    };                    //移动时裁剪区域的坐标 = 上次记录的定位 + (当前鼠标的位置 - 按下鼠标的位置)                    if(draging){                        if(t.ex + (pageX - startX) < 0){                            t.sx = 0;                        }else if(t.ex + (pageX - startX) + t.swidth > t.imgWidth){                            t.sx = t.imgWidth - t.swidth;                        }else {                            t.sx = t.ex + (pageX - startX);                        }                        if(t.ey + (pageY - startY) < 0){                            t.sy = 0;                        }else if(t.ey+ (pageY - startY) + t.sheight > t.imgHeight){                            t.sy = t.imgHeight - t.sheight;                        }else {                            t.sy = t.ey + (pageY - startY);                        }                        t.cutImage();                    }else{                        this.style.cursor = 'auto';                    }                };            }        }    };    postFile.init();</script></body></html>