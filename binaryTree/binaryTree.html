<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>binaryTree</title></head><body><h1>二叉树</h1><script>    function  BinaryTree() {        var Node = function(key){            this.key = key;            this.left = null;            this.right = null;        };        var root = null;        this.insert = function (key) {            var node = new Node(key);            if(root === null){                root = node;            }else {                insertNode(root,node);            }        };        var  insertNode = function (node,newNode) {            if(newNode.key< node.key){                if(node.left === null){                    node.left = newNode;                }else{                    insertNode(node.left,newNode);                }            }else{                if(node.right === null){                    node.right = newNode;                }else {                    insertNode(node.right,newNode);                }            }        };        var inOrderTarverseNode = function (node,callback) {            if(node !== null){                inOrderTarverseNode(node.left,callback);//递归调用访问节点左子树                callback(node.key);                inOrderTarverseNode(node.right,callback);            }        };        this.inOrderTraverse = function (callback) {          inOrderTarverseNode(root,callback);        };        var perOrderTraverseNode = function (node,callback) {          if(node !== null){              callback(node.key);              perOrderTraverseNode(node.left,callback);              perOrderTraverseNode(node.right,callback);          }        };        this.preOrderTraverse = function (callback) {            perOrderTraverseNode(root,callback);        };        var postOrderTraverseNode = function (node ,callback) {          if(node !== null){              postOrderTraverseNode(node.left,callback);              postOrderTraverseNode(node.right,callback);              callback(node.key);          }        };        this.postOrderTraverse = function (callback) {            postOrderTraverseNode(root,callback);        };        var minNode = function (node) {          if(node){              while (node && node.left !== null){                  node = node.left;              }              return node.key;          }          return null;        };        this.min = function () {            return minNode(root)        };        var maxNode = function (node) {            if(node){                while(node && node.right !== null){                    node = node.right;                }                return node.key;            }            return null;        };        this.max = function () {            return maxNode(root);        };        var searchNode = function (node ,key) {            if(node === null){                return false;            }            if(key<node.key){                return searchNode(node.left,key);            }else if(key > node.key){                return searchNode(node.right,key);            }else{                return true;            }        };        this.search = function (key) {            return searchNode(root,key);        };        var findMinNode = function (node) {            if(node){                while(node && node.left !== null){                    node = node.left;                }                return node;            }            return null;        };        var removeNode = function (node,key) {            if(node === null){                return null;            }            if(key<node.key){                node.left = removeNode(node.left,key);                return node;            }else if (key >node.key){                node.right = removeNode(node.right,key);                return node;            }else{                if(node.left === null && node.right === null){                    node = null;                    return node;                }                if(node.left === null){                    node = node.right;                    return node;                }else if(node.right === null){                    node = node.left;                    return node;                }                var aux = findMinNode(node.right);                node.key = aux.key;                node.right = removeNode(node.right,aux.key);            }        };        this.remove = function (key) {            root = removeNode(root,key);        }    }    var callback = function (key) {        console.log(key);    };    var nodes = [8,10,12,14,2,4,5,6,9];    var binaryTree = new BinaryTree();    nodes.forEach((key)=> binaryTree.insert(key));//    binaryTree.inOrderTraverse(callback);//    binaryTree.preOrderTraverse(callback);//    binaryTree.preOrderTraverse(callback);    //console.log('min node is : ' +binaryTree.min());    //console.log('max node is : ' +binaryTree.max());    console.log(binaryTree.search(4)? '9 is found':'9 is not found');    console.log(binaryTree.search(1)? '1 is found':'1 is not found');    console.log(binaryTree.search(10)? '10 is found':'10 is not found');</script></body></html>